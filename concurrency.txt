 1 - replace upsync with operations messages (and downsync)
 2 - enforce in-wall changes with messages ensures will work remotely (and e.g. queueing out of box)

organisation

initial 25min pomodoro: 
 - understand state (5 min?)
   o implement for svg wall only - fabric can still save/upsync
   o upsync happens when wall card_changed fire
     o svg wall triggers:
       - on_moved (self or part of group)
       - on_changed - from logical changed - fired from edit_done when losing focus
   o reload wall - presumably also problematic... fired by upsync
 - capture state (X)
 - spike implementation (requires more)

second 25min:
 - spike impl - atomic adds? actually did per-card change events
 - sketch out if reload wall has a place? what does it mean to keep it? if not, what does
   it mean to only load wall on initial and receive incremental update?  could do the
   reload in quiet time and provide trace of difference and how got there - captures
   weaknesses in incremental update?

NB: seems to get extra card change event?
(btw: not sure about logical vs view update model - seem to have to trigger
specific view update after (this could be single view refresh from logical a la "flux") )
- is this what i'm actually trying to solve?  what about where this data gets saved now that
  we're not doing the save wall - think we actually need to make server wall update json
  based on this message...  and have a plan! - comparing to original plan diag

third - just push through:
 - spike implementation
 - take notes on changes here
 - just make about concurrency not just adds
 - what are/should-be logical-card / -wall relations to their views?
   -> ** best to assume OK and find specific improvements - if need fundamental change will become clear
 - i'm looking around design of how what relates to what and to be honest it's just a bit of a mess...
   - sync client hooks up to visible wall so can't just have an invisible wall
     -> ** check out what sync client links up to and see what we can invert
       - sync client tied to global "visible_wall" :/
       - load_wall and save_wall only tie to global visible_wall
       - wall itself ties to (e.g. svg wall)
         - on_card_moving/changed/add (wired through to logicals)
         - move/add/update_card (wired through to logicals)
       - ** in sum, looks like (for svg at least) can move to logical-first
   - fabric wall has fabric 'cards' whereas svg wall uses logical 'cards'
     -> maybe effort to move to logical first
   - svg wall cards api etc is quite logical-first
     -> ** make effort to move stuff from svg wall to logical wall ( ** ditch fabric for spike)
   NB: is amazing how any slackness in design ends up in a right shambles - maybe why
     "flux" is such a good idea, or how containment and view/obj separation works when
     done consistently
 - need second browser to check sync up
   -> ** spike second browser tests


mainline implementation notes:
 - cover with func tests (simplify persistence and auth)
 - add in second browser
 - simplify logical card? - card view relation to just refresh from model (either move or rebuild? what about move speed?)
   -> ** just go with what have, make specific improvements, if improvements cohere, go with that
 -
